---
title: "part 1"
output: html_document
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
```

## R Markdown

This is an R Markdown document. Markdown is a simple formatting syntax for authoring HTML, PDF, and MS Word documents. For more details on using R Markdown see <http://rmarkdown.rstudio.com>.

When you click the **Knit** button a document will be generated that includes both content as well as the output of any embedded R code chunks within the document. You can embed an R code chunk like this:

```{r cars}
summary(cars)
```

## Including Plots

You can also embed plots, for example:

```{r pressure, echo=FALSE}
plot(pressure)
```

Note that the `echo = FALSE` parameter was added to the code chunk to prevent printing of the R code that generated the plot.



#********************import the datasets*********************

```{r}

air.quality <- read.csv('C:/Users/admin/Desktop/QUT 2019S1/dm/dataset/southbrisbane-aq-2018.csv') 
#air quality observation
#8760 observiations of 14 variables
weather.obs <- read.csv('C:/Users/admin/Desktop/QUT 2019S1/dm/dataset/weatherAUS.csv') # weather observation
# 157344 observations with 24 variables


#create a function that checks NA in percentage
percentmiss = function(x) 
              {sum(is.na(x))/length(x)*100}

```


# *********clean up southbrisbane-aq-2018.csv ****************

# Step 1. Remove error/irrelevant data

```{r}
#Check Summary 
cat("\nDataset Summary\n")
summary(air.quality)



#As from provided air quality dataset description, the negative value in PM2.5 and PM10 are resulting from instrument noise at low particle concentrations, so these values should be corrected (set to NA at this step)

air.quality$PM2.5..ug.m.3.[air.quality$PM2.5..ug.m.3. < 0] <- NA
air.quality$PM10..ug.m.3.[air.quality$PM10..ug.m.3. < 0] <- NA

```



# Step 2: Deal with NA

```{r}


# Check the Percentage of NA with our defined function. use function to check NA percentage
apply(air.quality,2,percentmiss)

# It is not too high so we can replace or remove all NA (In our case as our data is hourley basis, we don't want to remove the datapoint. Instead we will imptue the value with overall avg value)



#Imputation of multiple columns 
library(imputeTS)
air.quality <- na.mean(air.quality)

#keep the decimal places as original
names(air.quality)
air.quality[12:14] <- round(air.quality[12:14],1) 
air.quality[9:11] <- round(air.quality[9:11],3) 
air.quality[3:8] <- round(air.quality[3:8],1)

#air.quality <- na.omit(air.quality)

```



# Step 3. Check outliers.


```{r}
library(outliers)

# A. Wind.Speed..m.s has some outliers that can be removed. 
boxplot(air.quality$Wind.Speed..m.s.)

#calculate z-score
outlier_scores<- scores(air.quality$Wind.Speed..m.s.)

# every value more than three standard deviation from the mean we treat it as an outlier
is_outlier <- outlier_scores > 3 | outlier_scores < -3

# try to check the value of these outliers, and decide if we can remove the outliers
air.quality_outliers <- air.quality[outlier_scores > 3| outlier_scores < -3, ]
# head(air.quality_outliers)

# The outliers for wind.speed..ms. we see that outliers values are 4.4, 4.3, 5.1, compared to avg other values of 1, 2.
# However we assume on this particular time, there was extreme climatic condition that made weather windy, so we will not remove these outliers.


# B. Nitrogen.Oxides..ppm. has some outliers that can be removed. 
boxplot(air.quality$Nitrogen.Oxides..ppm.)

#calculate z-score
outlier_scores<- scores(air.quality$Nitrogen.Oxides..ppm.)

# every value more than three standard deviation from the mean we treat it as an outlier
is_outlier <- outlier_scores > 3 | outlier_scores < -3

# try to check the value of these outliers, and decide if we can remove the outliers
air.quality_outliers <- air.quality[outlier_scores > 3| outlier_scores < -3, ]
# head(air.quality_outliers)


#add a column is_outlier with result from is_outliers
air.quality$is_outlier <- is_outlier

# replace outliers with NA, which will be imputed later
air.quality$Nitrogen.Oxides..ppm.[air.quality$is_outlier== T] <- NA
 
# again use imputation and put rounding to original decimal places
library(imputeTS)
air.quality$Nitrogen.Oxides..ppm. <- na.mean(air.quality$Nitrogen.Oxides..ppm.)
air.quality$Nitrogen.Oxides..ppm. <- round(air.quality$Nitrogen.Oxides..ppm.,3) 

# Now as we have removed necessary outliers, we can detelet is_outlier column 
#names(air.quality)
air.quality <- air.quality[,-(15)]
```


# Step 4: Check Data types 


```{r}



# Check structure of air.quality:
#str(air.quality)

#removes scientific notication for numerical value of combined date and time:
options(scipen=999)


# Date and Time are factor, but we would like these two variables to be convertied to numerical as we will be dealing with K-means in later part.
# Also combining Date and time will be better idea as than using date and time separately 

air.quality$Date     <- as.Date(air.quality$Date, format = "%d/%m/%Y")
air.quality$DateTime <- paste(air.quality$Date, air.quality$Time)
air.quality$DateTime <- gsub("[: -]", "" , air.quality$DateTime, perl=TRUE)
air.quality$DateTime <- as.numeric(air.quality$DateTime)

# Now as we have desired format of DateTime, we can delete existing Date and Time variable.
#names(air.quality)

air.quality <- air.quality[,-(1:2)]


```

# Step 5: Remove Redundant variable

```{r}

names(air.quality)
# Here Nitrogen.Oxides..ppm. = Nitrogen.Oxide..ppm. + Nitrogen.Dioxide..ppm., So we can onily use Nitrogen.Oxides.

air.quality <- air.quality[,-(7:8)]  

# Here Wind.Speed.Std.Dev..m.s. is standard deviation of Wind.Speed..m.s. 
# And Wind.Sigma.Theta..deg. is standard deviation of Wind.Direction..degTN. 
# so we can remove Wind.Speed.Std.Dev..m.s. and Wind.Sigma.Theta..deg.

air.quality <- air.quality[,-(3:4)] 

# str(air.quality)

```



# ****************** clean up weatherAUS.csv ****************************************************



# Step 1. Remove error/irrelevant data

```{r}

# A. Filter Date 
# As we will be combining this data with previouseventually, for clean up we will only consider data of 2018 so that merging data provides consistency in regards with date and time. 
# Merging data of different timestamp can give false output!!


#str(weather.obs)

# Convert Date to Date data type first
weather.obs$Date     <- as.Date(weather.obs$Date, format = "%Y-%m-%d")

# create new dataframe with only data for 2018
weather.obs2018 <- weather.obs[format(weather.obs$Date,'%Y') == "2018", ]

# B. Filter City
# Now as the other dataset only contains data of city Brisbane, in order to provide consistant data and not to generate false output we will only be considering data for Brisbane city from this dataframe

weather.obsBris2018 <- weather.obs2018[weather.obs2018$Location == "Brisbane", ]

# C. Now as another dataset is hourly basis lets try to make this data as hourly basis

#install.packages("splitstackshape")
library(splitstackshape)
weather.obsBris2018 <- expandRows(weather.obsBris2018, 24, count.is.col=FALSE)

# Now we have 365X24=8760 observations for this dataset. 

#str(weather.obsBris2018)
#summary(weather.obsBris2018)

```


# Step 2: Check Data types 

```{r}

#str(weather.obsBris2018)

# A. Map YES to 1 and No to 0
weather.obsBris2018$RainToday <- as.integer(as.character(weather.obsBris2018$RainToday)=="Yes")
weather.obsBris2018$RainTomorrow <- as.integer(as.character(weather.obsBris2018$RainTomorrow)=="Yes")

#crosscheck output
#table(weather.obsBris2018$RainToday)

```


# Step 3: Remove Redundant variable

```{r}


#names(weather.obsBris2018)
#str(weather.obsBris2018)

# we can remove some features in this data set as we already have these information in abother dataset
# Infomration related to wind direction and wind speed

weather.obsBris2018 <- weather.obsBris2018 [,-(8:13)]


#This Dataset is based on Brisbane ie Location="Brisbane" so we can remove Location variable

weather.obsBris2018 <- weather.obsBris2018 [,-2]

#str(weather.obsBris2018)

```



# Step 4 : Deal with NA


```{r}


# Check the Percentage of NA with our defined function. use function to check NA percentage
apply(weather.obsBris2018,2,percentmiss)

# It is not too high so we can replace or remove all NA (In our case as our data is hourley basis, we don't want to remove the datapoint. Instead we will imptue the value with overall avg value)

#str(weather.obsBris2018)
#summary(weather.obsBris2018)

#Imputation of multiple columns (i.e. the whole data frame except first two column, which are catagorical variables)
library(imputeTS)
weather.obsBris2018 <- na.mean(weather.obsBris2018)

#keep the decimal places as original
names(weather.obsBris2018)
weather.obsBris2018[2:6] <- round(weather.obsBris2018[2:6],1) 
weather.obsBris2018[16] <- round(weather.obsBris2018[16],1)  
weather.obsBris2018$RainToday <- round(weather.obsBris2018$RainToday,0) 
weather.obsBris2018$RainTomorrow <- round(weather.obsBris2018$RainTomorrow,0) 


```





# Step 5: Merge features having data in 2 differnt timestamp.
# As we are mearging the two datasets on hourly basis, the features in 2 different times does not give significance value. So we can get mean from the two features and create an new variable.


```{r}

# Create a new variable taking mean from two similar variables. 
weather.obsBris2018$Pressure <- rowMeans(weather.obsBris2018[c('Pressure9am', 'Pressure3pm')], na.rm=TRUE)
weather.obsBris2018$Humidity <- rowMeans(weather.obsBris2018[c('Humidity9am', 'Humidity3pm')], na.rm=TRUE)
weather.obsBris2018$Cloud    <- rowMeans(weather.obsBris2018[c('Cloud9am', 'Cloud3pm')], na.rm=TRUE)
weather.obsBris2018$Temp    <- rowMeans(weather.obsBris2018[c('Temp9am', 'Temp3pm')], na.rm=TRUE)

# crosscheck the output
#head(weather.obsBris2018)


# As we have created new variable, we can remove existing one.
#names(weather.obsBris2018)
weather.obsBris2018 <- weather.obsBris2018 [,-(7:14)]

#summary(weather.obsBris2018)

```


# Step 6. Check outliers.


```{r}


# A. Wind.Speed..m.s has some outliers that can be removed. 
boxplot(weather.obsBris2018$Evaporation)

#calculate z-score
outlier_scores<- scores(weather.obsBris2018$Evaporation)

# every value more than three standard deviation from the mean we treat it as an outlier
is_outlier <- outlier_scores > 3 | outlier_scores < -3

# try to check the value of these outliers, and decide if we can remove the outliers
weather.obsBris2018_outliers <- weather.obsBris2018[outlier_scores > 3| outlier_scores < -3, ]
#head(weather.obsBris2018_outliers)

nrow(weather.obsBris2018_outliers)


#add a column is_outlier with result from is_outliers
weather.obsBris2018$is_outlier <- is_outlier

# replace outliers with NA, which will be imputed later
weather.obsBris2018$Evaporation[weather.obsBris2018$is_outlier== T] <- NA

#summary(weather.obsBris2018)
 
#Imputation of multiple columns 
weather.obsBris2018 <- na.mean(weather.obsBris2018)

#keep the decimal places as original
weather.obsBris2018$Evaporation <- round(weather.obsBris2018$Evaporation,1) 

# Now as we have removed necessary outliers, we can detelet is_outlier column 
#names(weather.obsBris2018)
weather.obsBris2018 <- weather.obsBris2018[,-(14)]

```




# ************ Merge  2 datasets *****************************************************

```{r}

# First lets copy the DateTime variable from air.quality dataframe to weather.obsBris2018 dataframe
# We will use this variable to merge the two dataframes
weather.obsBris2018$DateTime <- air.quality$DateTime

# merge two data frames by Date
brisbane.climateHour <- merge(air.quality,weather.obsBris2018,by="DateTime")


# new cleaned and mearged dataframe brisbane.climate is created with 22 variables and 8760 observations.

#Cross-Check
#head(brisbane.climate)
#summary(brisbane.climate)


#Lets also create Day wise Dataset "brisbane.climateDay"

brisbane.climateDay <- brisbane.climateHour
names(brisbane.climateDay)
brisbane.climateDay <- brisbane.climateDay[,-1] #remove DateTime

brisbane.climateDay <- aggregate(brisbane.climateDay, by=list(brisbane.climateDay$Date), FUN=mean, na.rm=TRUE)

head(brisbane.climateDay)
names(brisbane.climateDay)
brisbane.climateDay <- brisbane.climateDay[,-10] #Remove Date

# Convert Group.1 (date) to numeric
brisbane.climateDay$Group.1 <- gsub("[: -]", "" , brisbane.climateDay$Group.1, perl=TRUE)
str(brisbane.climateDay)
brisbane.climateDay$Group.1 <- as.numeric(brisbane.climateDay$Group.1)

#round to original decimal place
names(brisbane.climateDay)
brisbane.climateDay[2]    <- round(brisbane.climateDay[2],0)
brisbane.climateDay[3:5]  <- round(brisbane.climateDay[3:5],1)
brisbane.climateDay[6]  <- round(brisbane.climateDay[6],3)
brisbane.climateDay[7:9] <- round(brisbane.climateDay[7:9],1)
brisbane.climateDay[18:21] <- round(brisbane.climateDay[18:21],2)



str(brisbane.climateDay)

```


# ************ Corelation *****************************************************

```{r}
#install.packages("ggplot2")
library(ggplot2)

library(corrr)

names(brisbane.climateDay)

str(brisbane.climateDay)
d <- correlate(brisbane.climateDay)
a <- rearrange(d)
a

# From this dataframe we can see there is some +ve corelation between Carbon.Monoxide..ppm. (AirQuality) and Relative.Humidity....(Humidity)

# Lets examine the corelation between those two features.
cor.test(brisbane.climateDay$Nitrogen.Oxides..ppm., brisbane.climateDay$Wind.Direction..degTN., method="pearson") #0.4212319

plot(brisbane.climateDay$Nitrogen.Oxides..ppm., brisbane.climateDay$Pressure)
qplot(x = brisbane.climateDay$Nitrogen.Oxides..ppm.,
      y = brisbane.climateDay$Wind.Direction..degTN.,
      geom = c("point", "smooth"), 
      method = "lm", 
      alpha = I(1 / 5), 
      se = FALSE)
      

cor.test(brisbane.climateDay$Carbon.Monoxide..ppm., brisbane.climateDay$Temp, method="pearson") #-0.5066542 
qplot(x = brisbane.climateDay$Carbon.Monoxide..ppm.,
      y = brisbane.climateDay$Temp,
      geom = c("point", "smooth"), 
      method = "lm", 
      alpha = I(1 / 5), 
      se = FALSE)


```